<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCA Calculator</title>
    <link rel="icon" href="../Images/four-leaves.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #F8F9FA;
            --card-bg-color: #ffffff;
            --primary-color: #3b82f6;
            --primary-hover-color: #2563eb;
            --danger-color: #ef4444;
            --danger-hover-color: #dc2626;
            --success-color: #10b981;
            --text-primary: #111827;
            --text-secondary: #6B7280;
            --border-color: #E5E7EB;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            --status-connected-bg: #FEF3C7;
            --status-connected-text: #92400E;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 40px 24px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        header h1 {
            font-size: 36px;
            font-weight: 700;
        }
        
        header img {
            height: 40px;
        }

        .info-section {
            margin-bottom: 40px;
        }

        .info-section p {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .status.connected {
            background: var(--status-connected-bg);
            color: var(--status-connected-text);
        }

        .status.disconnected {
            background: #FEE2E2;
            color: #991B1B;
        }
        
        .section {
            background: var(--card-bg-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            margin-bottom: 32px;
        }
        
        .section-header {
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .section-header h2 {
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }
        
        .tabs {
            display: flex;
            gap: 8px;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 600;
            border-bottom: 2px solid transparent;
        }
        
        .tab-btn.active {
            color: var(--text-primary);
            border-bottom: 2px solid var(--primary-color);
        }
        
        .search-container {
            position: relative;
            width: 280px;
        }
        
        .search-container svg {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            background-color: #fff;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        #searchFilter {
            padding-left: 40px;
        }
        .form-input:focus {
             outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .table-wrapper {
             padding: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th {
            text-align: left;
            padding: 12px 16px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
            vertical-align: middle;
        }
        
        tbody tr:last-child td {
            border-bottom: none;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background-color: var(--card-bg-color);
            color: var(--text-primary);
        }
        .btn:hover {
            background-color: var(--bg-color);
        }
        .btn-calculating {
            background-color: #DBEAFE;
            color: #1E40AF;
            border-color: #BFDBFE;
        }
        .btn-delete {
            background-color: #FEE2E2;
            color: #991B1B;
            border-color: #FECACA;
        }

        .calc-result {
            color: var(--success-color);
            font-weight: 600;
        }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); animation: fadeIn 0.3s; display: flex; align-items: center; justify-content: center; padding: 20px; }
        .modal-content { background-color: white; padding: 0; border-radius: 12px; width: 100%; max-width: 1024px; max-height: 90vh; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); animation: slideDown 0.3s; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; border-bottom: 1px solid var(--border-color); }
        .modal-header h2 { font-size: 20px; margin: 0; }
        .modal-body { padding: 24px; overflow-y: auto; }
        .close { color: #94a3b8; font-size: 32px; font-weight: bold; cursor: pointer; transition: color 0.3s; }
        .close:hover { color: #475569; }
        .chart-container { position: relative; height: 65vh; min-height: 400px; width: 100%; }
        .chart-info { background: #f8fafc; padding: 15px; border-radius: 6px; margin-bottom: 15px; font-size: 14px; color: var(--text-secondary); }
        .google-table-header { background-color: #f8fafc; border-bottom: 1px solid var(--border-color); }
        .google-table-header th { padding: 12px 16px !important; font-weight: 600 !important; color: var(--text-secondary) !important; text-align: left !important; }
        .google-table-row td { padding: 12px 16px !important; border-bottom: 1px solid var(--border-color) !important; color: var(--text-secondary) !important; }
        .google-table-row-odd { background-color: var(--bg-color) !important; }
        .graph-tooltip { position: absolute; text-align: left; padding: 8px 12px; font: 12px sans-serif; background: #fff; border: 1px solid var(--border-color); border-radius: 8px; pointer-events: none; opacity: 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: opacity 0.2s; z-index: 1001; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid var(--border-color); border-top-color: var(--primary-color); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideDown { from { transform: translateY(-30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>

<body>
    <div id="graph-tooltip" class="graph-tooltip"></div>
    <div class="container">
        <header>
            <h1>LCA Calculator</h1>
            <img src="../Images/Logo.png" alt="CarbonX Logo">
        </header>

        <div class="info-section">
            <span class="status disconnected" id="status">Disconnected</span>
            <p><strong>Method:</strong> <span id="method-name">default</span></p>
            <p><strong>Impact Category:</strong> <span id="impact-category-name">default</span></p>
        </div>

        <div class="section">
            <div class="section-header">
                <div class="tabs">
                    <button class="tab-btn active" onclick="filterByTab('All')">All</button>
                    <button class="tab-btn" onclick="filterByTab('Process')">Process</button>
                    <button class="tab-btn" onclick="filterByTab('Flow')">Flow</button>
                </div>
                <div class="search-container">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" /></svg>
                    <input type="text" id="searchFilter" class="form-input" placeholder="Search...">
                </div>
            </div>
            <div class="table-wrapper">
                <div id="tableContainer"></div>
            </div>
        </div>

        <div class="section">
             <div class="section-header">
                <h2>Calculation</h2>
             </div>
             <div class="table-wrapper">
                <div id="lcaTableContainer"></div>
             </div>
        </div>

        <div id="chartModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="chartTitle">Impact Categories Breakdown</h2>
                    <span class="close" onclick="closeChart()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="chart-info" id="chartInfo"></div>
                    <div class="chart-container">
                        <div id="impactChart"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="inventoryModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="inventoryTitle">Inventory Results</h2>
                    <span class="close" onclick="closeInventory()">&times;</span>
                </div>
                <div class="modal-body" id="inventoryBody">
                </div>
            </div>
        </div>

        <div id="sankeyModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="sankeyTitle">Network Graph</h2>
                    <span class="close" onclick="closeSankeyModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="chart-info" id="sankeyInfo"></div>
                    <div id="sankeyChartContainer" class="chart-container">
                        <!-- D3 Network graph will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
        
        <div id="sankeyDataModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="sankeyDataTitle">Graph Data (Nodes & Edges)</h2>
                    <span class="close" onclick="closeSankeyDataModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="chart-info" id="sankeyDataInfo"></div>
                    <pre id="sankeyDataContainer" style="background: #f8fafc; padding: 15px; border-radius: 6px; white-space: pre-wrap; word-wrap: break-word;"></pre>
                </div>
            </div>
        </div>

    </div>
    <script>
        google.charts.load('current', { 'packages': ['table'] });

        const serverUrl = "http://localhost:8080";
        let requestId = 1;
        let allData = [];
        let filteredData = [];
        let selectedItems = [];
        let ipccMethodId = null;
        let ipccCategoryId = null;
        let allIpccCategories = [];
        let selectedCategoryName = "";
        let activeTab = "All";
        
        window.addEventListener('load', () => {
            testConnection();
            findLcaMethod();
            loadData();
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            renderCalculationTable();
        });

        async function testConnection() {
            try {
                const response = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "data/get/descriptors", params: { "@type": "Process" } })
                });
                if (response.ok) {
                    document.getElementById('status').textContent = 'Connected';
                    document.getElementById('status').className = 'status connected';
                }
            } catch (error) {
                document.getElementById('status').textContent = 'Disconnected';
                document.getElementById('status').className = 'status disconnected';
            }
        }

        async function findLcaMethod() {
            const searchMethodName = 'recipe 2016 v1.03';
            const searchMethodVariant = 'midpoint (h)';
            const searchCategoryName = 'climate change';
            document.getElementById('method-name').textContent = `Searching...`;
            try {
                const methodsResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "data/get/descriptors", params: { "@type": "ImpactMethod" } })
                });
                const methodsData = await methodsResponse.json();
                if (!Array.isArray(methodsData.result)) throw new Error('Could not retrieve impact methods.');
                const recipeMethod = methodsData.result.find(m => m.name && m.name.toLowerCase().includes(searchMethodName) && m.name.toLowerCase().includes(searchMethodVariant));
                if (!recipeMethod) throw new Error(`Method "${searchMethodName} - ${searchMethodVariant}" not found.`);
                ipccMethodId = recipeMethod['@id'];
                document.getElementById('method-name').textContent = recipeMethod.name;
                const methodDetailResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "data/get", params: { "@type": "ImpactMethod", "@id": ipccMethodId } })
                });
                const methodDetail = await methodDetailResponse.json();
                if (!methodDetail.result || !Array.isArray(methodDetail.result.impactCategories)) throw new Error('Could not retrieve categories.');
                allIpccCategories = methodDetail.result.impactCategories;
                const climateCategory = allIpccCategories.find(cat => cat.name && cat.name.toLowerCase().includes(searchCategoryName)) || allIpccCategories[0];
                if (climateCategory) {
                    ipccCategoryId = climateCategory['@id'];
                    selectedCategoryName = climateCategory.name;
                    document.getElementById('impact-category-name').textContent = selectedCategoryName;
                } else { throw new Error('No impact categories found.'); }
            } catch (e) {
                document.getElementById('method-name').textContent = e.message;
                document.getElementById('impact-category-name').textContent = "Error";
            }
        }
        
        function filterByTab(tabName) {
            activeTab = tabName;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            applyFilters();
        }

        async function loadData() {
            const container = document.getElementById('tableContainer');
            container.innerHTML = `<div style="padding: 40px; text-align: center;"><div class="loading" style="margin: auto;"></div><p style="margin-top: 1em;">Loading data...</p></div>`;
            try {
                const [processRes, flowRes] = await Promise.all([
                    fetch(serverUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ "jsonrpc": "2.0", "id": requestId++, "method": "data/get/descriptors", "params": { "@type": "Process" } }) }),
                    fetch(serverUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ "jsonrpc": "2.0", "id": requestId++, "method": "data/get/descriptors", "params": { "@type": "Flow" } }) })
                ]);
                const processData = await processRes.json();
                const flowData = await flowRes.json();
                allData = [];
                if (Array.isArray(processData.result)) allData = allData.concat(processData.result.map(x => ({ ...x, groupType: "Process" })));
                if (Array.isArray(flowData.result)) allData = allData.concat(flowData.result.map(x => ({ ...x, groupType: "Flow" })));
                applyFilters();
            } catch (e) {
                container.innerHTML = `<div class="no-results" style="color: var(--danger-color);">${e.message}</div>`;
            }
        }

        function applyFilters() {
            const searchTerm = document.getElementById('searchFilter').value.toLowerCase();
            let dataToFilter = (activeTab === 'All') ? allData : allData.filter(item => item.groupType === activeTab);
            filteredData = dataToFilter.filter(item => !searchTerm || (item.name && item.name.toLowerCase().includes(searchTerm)) || (item.category && item.category.toLowerCase().includes(searchTerm)));
            renderDataTable();
        }

        function renderDataTable() {
            const container = document.getElementById('tableContainer');
            if (filteredData.length === 0) {
                container.innerHTML = '<div class="no-results">No items match the current filters.</div>';
                return;
            }
            let html = `<table><thead><tr><th>Name</th><th>Type</th><th>Category</th><th>Location</th><th>Add</th></tr></thead><tbody>`;
            filteredData.forEach((item, idx) => {
                html += `<tr>
                        <td>${escapeHtml(item.name || '-')}</td>
                        <td>${escapeHtml(item.groupType)}</td>
                        <td>${escapeHtml(item.category || '-')}</td>
                        <td>${escapeHtml(item.location || '-')}</td>
                        <td><button class="btn" onclick="addItem(${filteredData.indexOf(item)})">Add</button></td>
                        </tr>`;
            });
            html += `</tbody></table>`;
            container.innerHTML = html;
        }

        function addItem(idx) {
            const item = filteredData[idx];
            if (!selectedItems.some(sel => sel['@id'] === item['@id'])) {
                selectedItems.push({ ...item, carbonResult: null, carbonResultRaw: null, calcLoading: false, fullImpacts: null, carbonUnit: null, weight: 1, inventory: null, inventoryLoading: false, sankeyData: null });
                renderCalculationTable();
            }
        }
        
        function renderCalculationTable() {
            const container = document.getElementById('lcaTableContainer');
            if (selectedItems.length === 0) {
                container.innerHTML = '<div class="no-results" style="padding: 20px;">No items added for calculation.</div>';
                return;
            }
            let html = `<table><thead><tr>
                <th>Name</th>
                <th>Amount (eg. 1 kg)</th>
                <th>Result (Impact Category)</th>
                <th>Output</th>
                <th>Delete</th>
                </tr></thead><tbody>`;

            selectedItems.forEach((item, idx) => {
                let progressCell = '<em>(Not calculated)</em>';
                if (item.calcLoading) {
                    progressCell = '<button class="btn btn-calculating"><div class="loading" style="width:16px; height:16px; border-width:2px; margin-right: 8px;"></div>Calculating</button>';
                } else if (item.carbonResult !== null) {
                    progressCell = `<div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="showChart(${idx})">Impacts</button>
                        <button class="btn" onclick="loadInventory(${idx}, true)">Inventory</button>
                        <button class="btn" onclick="generateSankeyGraph(${idx})">Graph</button>
                        <button class="btn" onclick="showSankeyData(${idx})">Data</button>
                    </div>`;
                } else {
                    progressCell = `<button class="btn" style="background:var(--primary-color); color:white;" onclick="runCarbon(${idx})">Calculate</button>`;
                }

                html += `<tr>
                    <td>${escapeHtml(item.name)}</td>
                    <td><input type="number" class="form-input" style="width: 120px; padding: 8px;" value="${item.weight}" onchange="updateWeight(${idx}, this.value)"></td>
                    <td class="calc-result">${item.carbonResult ? `${item.carbonResult} ${item.carbonUnit}` : 'N/A'}</td>
                    <td>${progressCell}</td>
                    <td><button class="btn btn-delete" onclick="removeLcaItem(${idx})">Delete</button></td>
                    </tr>`;
            });
            html += `</tbody></table>`;
            container.innerHTML = html;
        }


        function updateWeight(idx, value) {
            const newWeight = parseFloat(value);
            if (!isNaN(newWeight)) {
                selectedItems[idx].weight = newWeight;
                runCarbon(idx);
            }
        }

        function showChart(idx) {
            const item = selectedItems[idx];
            if (!item.fullImpacts) return;
            const modal = document.getElementById('chartModal');
            modal.style.display = 'flex';
            document.getElementById('chartTitle').textContent = `Impact Categories: ${item.name}`;

            let chartInfoHTML = `<strong>Process:</strong> ${escapeHtml(item.name)}<br>
                                 <strong>Category:</strong> ${escapeHtml(item.category || 'N/A')}<br>
                                 <strong>Total Categories:</strong> ${item.fullImpacts.length}`;

            if (item.carbonResult !== null) {
                chartInfoHTML += `<br><strong style="color: var(--success-color);">Selected Impact Result: ${item.carbonResult} ${item.carbonUnit}</strong>`;
            }
            document.getElementById('chartInfo').innerHTML = chartInfoHTML;
            
            const data = new google.visualization.DataTable();
            data.addColumn('string', 'Impact Category');
            data.addColumn('number', 'Amount');
            data.addColumn('string', 'Unit');

            const sortedImpacts = [...item.fullImpacts].sort((a, b) => Math.abs(b.amount || 0) - Math.abs(a.amount || 0));
            
            sortedImpacts.forEach(impact => {
                data.addRow([
                    impact.impactCategory.name,
                    { v: impact.amount, f: parseFloat(impact.amount).toPrecision(3) },
                    impact.impactCategory.refUnit
                ]);
            });

            const table = new google.visualization.Table(document.getElementById('impactChart'));
            
            table.draw(data, { 
                showRowNumber: true, 
                width: '100%', 
                height: '100%',
                sortColumn: 1,
                sortAscending: false,
                cssClassNames: {
                    headerRow: 'google-table-header',
                    tableRow: 'google-table-row',
                    oddTableRow: 'google-table-row-odd',
                }
            });
        }

        function closeChart() {
            document.getElementById('chartModal').style.display = 'none';
        }

        function removeLcaItem(idx) {
            selectedItems.splice(idx, 1);
            renderCalculationTable();
        }

        async function runCarbon(idx) {
            const item = selectedItems[idx];
            if (!ipccMethodId || !ipccCategoryId) return;

            selectedItems[idx].calcLoading = true;
            renderCalculationTable();

            let resultId = null;
            try {
                const setupResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        jsonrpc: "2.0", id: requestId++, method: "result/calculate",
                        params: {
                            target: { "@type": "Process", "@id": item['@id'] },
                            impactMethod: { "@type": "ImpactMethod", "@id": ipccMethodId },
                            amount: parseFloat(item.weight) || 1.0
                        }
                    })
                });
                const setupData = await setupResponse.json();
                if (setupData.error) throw new Error(`Calc setup: ${JSON.stringify(setupData.error)}`);
                resultId = setupData.result['@id'];

                let isReady = false;
                for (let i = 0; i < 60 && !isReady; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const stateResponse = await fetch(serverUrl, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/state", params: { "@id": resultId } })
                    });
                    const stateData = await stateResponse.json();
                    if (stateData.result && stateData.result.isReady) isReady = true;
                }
                if (!isReady) throw new Error(`Calculation timeout`);

                const impactResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/total-impacts", params: { "@id": resultId } })
                });
                const impactData = await impactResponse.json();
                if (impactData.error) throw new Error(`Impact retrieval: ${JSON.stringify(impactData.error)}`);
                
                selectedItems[idx].fullImpacts = impactData.result;
                const categoryResult = (impactData.result || []).find(r => r.impactCategory && r.impactCategory['@id'] === ipccCategoryId);

                if (categoryResult) {
                    selectedItems[idx].carbonResultRaw = categoryResult.amount;
                    selectedItems[idx].carbonResult = parseFloat(categoryResult.amount).toPrecision(3);
                    selectedItems[idx].carbonUnit = categoryResult.impactCategory.refUnit;
                } else {
                    selectedItems[idx].carbonResult = "N/A";
                }

            } catch (e) {
                console.error('[ERROR]', e);
                selectedItems[idx].carbonResult = "Error";
            } finally {
                if (resultId) {
                    await fetch(serverUrl, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/dispose", params: { "@id": resultId } })
                    });
                }
            }
            selectedItems[idx].calcLoading = false;
            renderCalculationTable();
        }
        
        async function loadInventory(idx, showWhenDone = false) {
             const item = selectedItems[idx];
            if (item.groupType !== "Process") return;
            item.inventoryLoading = true;
            renderCalculationTable();

            let resultId = null;
            try {
                 const setupResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        jsonrpc: "2.0", id: requestId++, method: "result/calculate",
                        params: {
                            target: { "@type": "Process", "@id": item['@id'] },
                            amount: parseFloat(item.weight) || 1.0
                        }
                    })
                });
                const setupData = await setupResponse.json();
                if (setupData.error) throw new Error(`Inventory Calc setup: ${JSON.stringify(setupData.error)}`);
                resultId = setupData.result['@id'];

                let isReady = false;
                for (let i = 0; i < 60 && !isReady; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const stateResponse = await fetch(serverUrl, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/state", params: { "@id": resultId } })
                    });
                    const stateData = await stateResponse.json();
                    if (stateData.result && stateData.result.isReady) isReady = true;
                }
                if (!isReady) throw new Error(`Inventory calculation timeout`);

                const inventoryRes = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/total-flows", params: { "@id": resultId } })
                });
                const inventoryData = await inventoryRes.json();
                if (inventoryData.error) throw new Error(`Inventory fetch: ${JSON.stringify(inventoryData.error)}`);
                
                selectedItems[idx].inventory = (inventoryData.result || []).map(i => ({
                    flow: { name: i.enviFlow?.flow?.name || 'Unknown', category: i.enviFlow?.flow?.category || '-' },
                    isInput: i.enviFlow?.isInput || false,
                    amount: i.amount || 0,
                    unit: { name: i.enviFlow?.flow?.refUnit || 'unit' }
                }));

            } catch (e) {
                alert("Error loading inventory: " + e.message);
                console.error(e);
                selectedItems[idx].inventory = null;
            } finally {
                if (resultId) {
                    await fetch(serverUrl, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/dispose", params: { "@id": resultId } })
                    });
                }
            }
            item.inventoryLoading = false;
            renderCalculationTable();
            if (showWhenDone && selectedItems[idx].inventory) showInventory(idx);
        }

        function showInventory(idx) {
             const item = selectedItems[idx];
            if (!item.inventory) {
                loadInventory(idx, true);
                return;
            };

            const nonZero = item.inventory.filter(f => f.amount !== 0);
            const inputs = nonZero.filter(f => f.isInput).sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
            const outputs = nonZero.filter(f => !f.isInput).sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));

            const modal = document.getElementById('inventoryModal');
            document.getElementById('inventoryTitle').textContent = `Inventory Results: ${item.name}`;
            const modalBody = document.getElementById('inventoryBody');
            
            const createTableHtml = (title, flows) => {
                if(flows.length === 0) return '';
                let rows = flows.map(f => `<tr>
                        <td>${escapeHtml(f.flow.name)}</td>
                        <td>${escapeHtml(f.flow.category)}</td>
                        <td style="text-align: right;">${parseFloat(f.amount).toPrecision(3)}</td>
                        <td>${escapeHtml(f.unit.name)}</td>
                    </tr>`).join('');
                return `<h3 style="margin-top:20px;">${title} (${flows.length})</h3><div class="table-wrapper"><table style="table-layout: fixed;"><thead><tr><th style="width: 40%;">Flow Name</th><th>Category</th><th>Amount</th><th>Unit</th></tr></thead><tbody>${rows}</tbody></table></div>`;
            };
            
            modalBody.innerHTML = `<div class="chart-info"><strong>Process:</strong> ${escapeHtml(item.name)}<br><strong>Total Non-Zero Flows:</strong> ${nonZero.length}</div>` + createTableHtml('Inputs', inputs) + createTableHtml('Outputs', outputs);
            modal.style.display = 'flex';
        }
        
        async function generateSankeyGraph(idx) {
            const item = selectedItems[idx];
            const modal = document.getElementById('sankeyModal');
            const container = document.getElementById('sankeyChartContainer');
            const infoEl = document.getElementById('sankeyInfo');
            const titleEl = document.getElementById('sankeyTitle');

            titleEl.textContent = `Network Graph: ${item.name}`;
            modal.style.display = 'flex';
            container.innerHTML = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;"><div class="loading"></div><p style="margin-top: 20px;">Generating graph data...</p></div>`;
            infoEl.innerHTML = `<strong>Process:</strong> ${escapeHtml(item.name)}<br><strong>Selected Impact:</strong> ${selectedCategoryName}`;

            let resultId = null;
            try {
                const setupResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        jsonrpc: "2.0", id: requestId++, method: "result/calculate",
                        params: {
                            target: { "@type": "Process", "@id": item['@id'] },
                            impactMethod: { "@type": "ImpactMethod", "@id": ipccMethodId },
                            amount: parseFloat(item.weight) || 1.0
                        }
                    })
                });
                const setupData = await setupResponse.json();
                if (setupData.error) throw new Error(`Graph Calc setup: ${JSON.stringify(setupData.error)}`);
                resultId = setupData.result['@id'];

                let isReady = false;
                for (let i = 0; i < 60 && !isReady; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const stateResponse = await fetch(serverUrl, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/state", params: { "@id": resultId } })
                    });
                    const stateData = await stateResponse.json();
                    if (stateData.result && stateData.result.isReady) isReady = true;
                }
                if (!isReady) throw new Error(`Graph calculation timeout`);

                const sankeyResponse = await fetch(serverUrl, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        jsonrpc: "2.0", id: requestId++, method: "result/sankey",
                        params: {
                            "@id": resultId,
                            config: {
                                impactCategory: { "@type": "ImpactCategory", "@id": ipccCategoryId },
                                maxNodes: 30
                            }
                        }
                    })
                });
                const sankeyData = await sankeyResponse.json();
                if (sankeyData.error) throw new Error(`Graph data fetch: ${JSON.stringify(sankeyData.error)}`);

                selectedItems[idx].sankeyData = sankeyData.result;
                drawNetworkGraph(sankeyData.result);

            } catch (e) {
                console.error('[GRAPH ERROR]', e);
                container.innerHTML = `<div class="no-results" style="color:var(--danger-color)">Error generating graph: ${e.message}</div>`;
            } finally {
                 if (resultId) {
                    await fetch(serverUrl, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ jsonrpc: "2.0", id: requestId++, method: "result/dispose", params: { "@id": resultId } })
                    });
                }
            }
        }
        
        function drawNetworkGraph(data) {
            const container = document.getElementById('sankeyChartContainer');
            container.innerHTML = '';
            const tooltip = d3.select("#graph-tooltip");

            if (!data || !data.nodes || data.nodes.length === 0) {
                container.innerHTML = `<div class="no-results">No data available to display the graph.</div>`;
                return;
            }

            const width = container.clientWidth;
            const height = container.clientHeight;
            const svg = d3.select(container).append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height]);

            const links = (data.edges || []).map(edge => ({
                source: edge.providerIndex,
                target: edge.nodeIndex
            }));

            const nodeMap = new Map(data.nodes.map(n => [n.index, {
                id: n.index,
                name: n.techFlow.provider.name,
                directResult: n.directResult,
                totalResult: n.totalResult,
                flowName: n.techFlow.flow.name
            }]));
            
            const incomingLinks = new Map();
            links.forEach(link => {
                if (!incomingLinks.has(link.target)) incomingLinks.set(link.target, []);
                incomingLinks.get(link.target).push(link.source);
            });
            
            const queue = [{ nodeId: data.rootIndex, layer: 0 }];
            const visited = new Set([data.rootIndex]);
            if (nodeMap.has(data.rootIndex)) {
                nodeMap.get(data.rootIndex).layer = 0;
            }

            let maxLayer = 0;
            while (queue.length > 0) {
                const { nodeId, layer } = queue.shift();
                maxLayer = Math.max(maxLayer, layer);
                const sources = incomingLinks.get(nodeId) || [];
                sources.forEach(sourceId => {
                    if (!visited.has(sourceId)) {
                        visited.add(sourceId);
                        if (nodeMap.has(sourceId)) {
                             nodeMap.get(sourceId).layer = layer + 1;
                        }
                        queue.push({ nodeId: sourceId, layer: layer + 1 });
                    }
                });
            }

            const nodes = Array.from(nodeMap.values());
            const color = d3.scaleOrdinal(d3.schemeTableau10);
            
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide(35));

            svg.append("defs").selectAll("marker")
                .data(["end"])
                .enter().append("marker")
                .attr("id", String)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 21)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#999");

            const link = svg.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("marker-end", "url(#end)");
            
            link.on("mouseover", function(event, d) {
                const sourceNode = nodeMap.get(d.source.id);
                const targetNode = nodeMap.get(d.target.id);
                const value = sourceNode.totalResult;

                tooltip.style("opacity", .9);
                tooltip.html(`
                    <strong>From:</strong> ${escapeHtml(sourceNode.name)}<br>
                    <strong>To:</strong> ${escapeHtml(targetNode.name)}<br>
                    <hr style="margin: 3px 0; border:0; border-top: 1px solid #eee">
                    <strong>Flow:</strong> ${escapeHtml(sourceNode.flowName)}<br>
                    <strong>Weight:</strong> ${parseFloat(value).toPrecision(3)}`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.style("opacity", 0);
            });

            const node = svg.append("g")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .call(drag(simulation));

            node.append("circle")
                .attr("r", 12)
                .attr("fill", d => color(d.layer))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5);

            node.append("text")
                .attr("x", 18)
                .attr("y", 4)
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => d.name.length > 30 ? d.name.substring(0,30) + "..." : d.name);

            node.on("mouseover", function(event, d) {
                tooltip.style("opacity", .9);
                tooltip.html(`
                    <strong>Process:</strong> ${escapeHtml(d.name)}<br>
                    <hr style="margin: 3px 0; border:0; border-top: 1px solid #eee">
                    <strong>Total Result:</strong> ${parseFloat(d.totalResult).toPrecision(3)}<br>
                    <strong>Direct Result:</strong> ${parseFloat(d.directResult).toPrecision(3)}`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.style("opacity", 0);
            });


            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }
        }


        function showSankeyData(idx) {
            const item = selectedItems[idx];
            if (!item || !item.sankeyData) {
                alert("Graph data not available. Please generate the graph first by clicking the 'Graph' button.");
                return;
            }

            const modal = document.getElementById('sankeyDataModal');
            const titleEl = document.getElementById('sankeyDataTitle');
            const infoEl = document.getElementById('sankeyDataInfo');
            const container = document.getElementById('sankeyDataContainer');

            titleEl.textContent = `Graph Data: ${item.name}`;
            infoEl.innerHTML = `<strong>Process:</strong> ${escapeHtml(item.name)}<br><strong>Selected Impact:</strong> ${selectedCategoryName}`;
            container.textContent = JSON.stringify(item.sankeyData, null, 2);

            modal.style.display = 'flex';
        }

        function closeSankeyModal() {
            document.getElementById('sankeyModal').style.display = 'none';
        }

        function closeSankeyDataModal() {
            document.getElementById('sankeyDataModal').style.display = 'none';
        }

        function escapeHtml(text) { 
            if (typeof text !== 'string') return text;
            const div=document.createElement('div');
            div.innerText=text;
            return div.innerHTML;
        } 
        function closeInventory() { document.getElementById('inventoryModal').style.display = 'none'; }
        
        window.onclick = function(event) { if (event.target.matches('.modal')) event.target.style.display = 'none'; }
        
        // Expose functions to global scope
        window.filterByTab = filterByTab;
        window.addItem = addItem;
        window.removeLcaItem = removeLcaItem;
        window.runCarbon = runCarbon;
        window.showChart = showChart;
        window.closeChart = closeChart;
        window.loadInventory = loadInventory;
        window.showInventory = showInventory;
        window.closeInventory = closeInventory;
        window.updateWeight = updateWeight;
        window.generateSankeyGraph = generateSankeyGraph;
        window.closeSankeyModal = closeSankeyModal;
        window.showSankeyData = showSankeyData;
        window.closeSankeyDataModal = closeSankeyDataModal;
        window.toggleDetails = toggleDetails;

    </script>
</body>

</html>


