<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenLCA IPC Client</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    .status {
      display: inline-block;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
    }

    .status.connected {
      background: #10b981;
      color: white;
    }

    .status.disconnected {
      background: #ef4444;
      color: white;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .panel {
      background: white;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    h2 {
      color: #333;
      margin-bottom: 15px;
      font-size: 18px;
    }

    .method-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      width: 100%;
    }

    button:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    button:active {
      transform: translateY(0);
    }

    .custom-request {
      margin-top: 20px;
    }

    textarea {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      resize: vertical;
      margin-bottom: 10px;
    }

    textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .output-panel {
      background: white;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .view-toggle {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .view-toggle button {
      flex: 1;
      min-width: 120px;
      padding: 10px;
      font-size: 13px;
    }

    .view-toggle button.active {
      background: #10b981;
    }

    .info-box {
      background: #eff6ff;
      border-left: 4px solid #3b82f6;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 14px;
      color: #1e40af;
    }

    /* Card View */
    .results-container {
      max-height: 600px;
      overflow-y: auto;
    }

    .result-item {
      padding: 15px 20px;
      border-bottom: 1px solid #e5e7eb;
      transition: background 0.2s;
    }

    .result-item:hover {
      background: #f9fafb;
    }

    .result-name {
      font-size: 16px;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 4px;
    }

    .result-type {
      display: inline-block;
      padding: 4px 10px;
      background: #667eea;
      color: white;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .result-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .result-field {
      font-size: 13px;
      color: #64748b;
    }

    .result-field strong {
      color: #475569;
      font-weight: 600;
    }

    .results-summary {
      padding: 15px 20px;
      background: #f8fafc;
      border-bottom: 2px solid #e5e7eb;
      font-weight: 600;
      color: #475569;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    /* Table View */
    .table-container {
      overflow-x: auto;
      max-height: 600px;
      overflow-y: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    thead {
      position: sticky;
      top: 0;
      background: #f8fafc;
      z-index: 10;
    }

    th {
      text-align: left;
      padding: 12px 15px;
      font-weight: 600;
      color: #475569;
      border-bottom: 2px solid #e5e7eb;
      white-space: nowrap;
    }

    td {
      padding: 12px 15px;
      border-bottom: 1px solid #e5e7eb;
      color: #64748b;
    }

    tr:hover {
      background: #f9fafb;
    }

    .table-id {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #94a3b8;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Network Graph */
    #networkGraph {
      width: 100%;
      height: 600px;
      background: #f8fafc;
      border-radius: 6px;
      position: relative;
    }

    .node {
      cursor: pointer;
    }

    .node circle {
      stroke: #fff;
      stroke-width: 2px;
    }

    .node text {
      font-size: 11px;
      pointer-events: none;
      text-anchor: middle;
    }

    .link {
      stroke: #94a3b8;
      stroke-opacity: 0.6;
      stroke-width: 1.5px;
    }

    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      max-width: 300px;
      z-index: 1000;
    }

    /* Raw JSON */
    .raw-json {
      background: #1e293b;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 600px;
      overflow-y: auto;
      line-height: 1.6;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #94a3b8;
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .loading {
      display: inline-block;
      width: 40px;
      height: 40px;
      border: 4px solid #f3f4f6;
      border-top-color: #667eea;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .graph-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .graph-controls button {
      padding: 8px 12px;
      font-size: 12px;
      width: auto;
    }

    /* Product → Process Mapper */
    .mapper {
      background: white;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .mapper-row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .mapper input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      font-size: 14px;
    }

    .mapper input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
    }

    .suggestions {
      margin-top: 8px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
      max-height: 240px;
      overflow-y: auto;
      background: white;
    }

    .suggestion-item {
      padding: 10px 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .suggestion-item:hover {
      background: #f9fafb;
    }

    .match-badge {
      background: #10b981;
      color: white;
      border-radius: 999px;
      font-size: 11px;
      padding: 2px 8px;
      align-self: center;
      white-space: nowrap;
    }

    .mapper-meta {
      margin-top: 8px;
      font-size: 12px;
      color: #64748b;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>OpenLCA IPC Client</h1>
      <p style="color: #666; margin-bottom: 10px;">Connected to: <strong>http://localhost:8080</strong></p>
      <span class="status disconnected" id="status">Disconnected</span>
      <div class="mapper" id="mapper">
        <h2>Product → Process Mapper</h2>
        <div class="info-box" id="mapperInfo">Loading process data in the background…</div>
        <div class="mapper-row">
          <div>
            <input id="productInput" type="text" placeholder="Type a product name (e.g., Steel sheet, Plastic bottle)" autocomplete="off" />
            <div class="suggestions" id="suggestions" style="display:none;"></div>
            <div class="mapper-meta" id="matchMeta"></div>
          </div>
          <div>
            <button id="viewMatchBtn" disabled>View Best Match</button>
          </div>
        </div>
      </div>
    </div>

    <div class="controls-grid">
      <div class="panel">
        <h2>Quick Methods</h2>
        <div class="info-box">
          Click any button to test common OpenLCA IPC methods
        </div>
        <div class="method-grid">
          <button onclick="getDescriptors('Process')">Processes</button>
          <button onclick="getDescriptors('Flow')">Flows</button>
          <button onclick="getDescriptors('FlowProperty')">Flow Properties</button>
          <button onclick="getDescriptors('UnitGroup')">Unit Groups</button>
          <button onclick="getDescriptors('ImpactMethod')">Impact Methods</button>
          <button onclick="getDescriptors('ImpactCategory')">Impact Categories</button>
        </div>
      </div>

      <div class="panel">
        <h2>Custom Request</h2>
        <div class="info-box">
          Enter your custom JSON-RPC request below
        </div>
        <div class="custom-request">
          <textarea id="customPayload" placeholder="Enter JSON-RPC payload...">{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "data/get/descriptors",
  "params": {
    "@type": "Process"
  }
}</textarea>
          <button onclick="sendCustomRequest()">Send Custom Request</button>
        </div>
      </div>
    </div>

    <div class="output-panel">
      <h2>Response Output</h2>
      <div class="view-toggle">
        <button onclick="switchView('cards')" id="cardsBtn" class="active">Cards</button>
        <button onclick="switchView('table')" id="tableBtn">Table</button>
        <button onclick="switchView('network')" id="networkBtn">Network Graph</button>
        <button onclick="switchView('raw')" id="rawBtn">Raw JSON</button>
      </div>
      <div id="output">
        <div class="empty-state">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
          </svg>
          <p>Waiting for request...</p>
          <p style="font-size: 12px; margin-top: 8px;">Click a button above to fetch data</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    const serverUrl = "http://localhost:8080";
    let requestId = 1;
    let currentView = 'cards';
    let lastResponse = null;
    let cachedProcesses = [];
    let bestMatch = null;

    window.addEventListener('load', () => {
      testConnection();
      preloadProcesses();
      setupMapper();
    });

    async function testConnection() {
      try {
        const response = await fetch(serverUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: requestId++,
            method: "data/get/descriptors",
            params: {
              "@type": "Process"
            }
          })
        });
        
        if (response.ok) {
          document.getElementById('status').textContent = 'Connected';
          document.getElementById('status').className = 'status connected';
        }
      } catch (error) {
        document.getElementById('status').textContent = 'Disconnected';
        document.getElementById('status').className = 'status disconnected';
      }
    }

    function switchView(view) {
      currentView = view;
      ['cardsBtn', 'tableBtn', 'networkBtn', 'rawBtn'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById(view + 'Btn').classList.add('active');
      
      if (lastResponse) {
        displayResponse(lastResponse);
      }
    }

    function displayResponse(data) {
      lastResponse = data;
      const output = document.getElementById('output');
      
      if (data.error) {
        output.innerHTML = `
          <div class="empty-state" style="color: #ef4444;">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p style="font-weight: 600;">Error ${data.error.code}</p>
            <p style="font-size: 14px; margin-top: 8px;">${data.error.message}</p>
          </div>
        `;
        return;
      }
      
      if (!data.result || !Array.isArray(data.result) || data.result.length === 0) {
        output.innerHTML = `
          <div class="empty-state">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"></path>
            </svg>
            <p>No results found</p>
          </div>
        `;
        return;
      }

      const results = data.result;

      if (currentView === 'raw') {
        output.innerHTML = `<div class="raw-json">${JSON.stringify(data, null, 2)}</div>`;
      } else if (currentView === 'table') {
        displayTable(results, output);
      } else if (currentView === 'network') {
        displayNetwork(results, output);
      } else {
        displayCards(results, output);
      }
    }

    function displayCards(results, output) {
      let html = `
        <div class="results-container">
          <div class="results-summary">
            Found ${results.length} item${results.length !== 1 ? 's' : ''}
          </div>
      `;
      
      results.forEach(item => {
        html += `
          <div class="result-item">
            <div>
              <div class="result-name">${escapeHtml(item.name || 'Unnamed')}</div>
              ${item['@type'] ? `<span class="result-type">${item['@type']}</span>` : ''}
            </div>
            <div class="result-details">
              ${item.category ? `<div class="result-field"><strong>Category:</strong> ${escapeHtml(item.category)}</div>` : ''}
              ${item.refUnit ? `<div class="result-field"><strong>Ref Unit:</strong> ${escapeHtml(item.refUnit)}</div>` : ''}
              ${item.flowType ? `<div class="result-field"><strong>Flow Type:</strong> ${escapeHtml(item.flowType)}</div>` : ''}
              ${item.processType ? `<div class="result-field"><strong>Process Type:</strong> ${escapeHtml(item.processType)}</div>` : ''}
              ${item.location ? `<div class="result-field"><strong>Location:</strong> ${escapeHtml(item.location)}</div>` : ''}
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      output.innerHTML = html;
    }

    function displayTable(results, output) {
      const allKeys = new Set();
      results.forEach(item => {
        Object.keys(item).forEach(key => allKeys.add(key));
      });

      const keys = Array.from(allKeys).filter(k => k !== '@id');
      
      let html = `
        <div class="table-container">
          <div class="results-summary">
            Found ${results.length} item${results.length !== 1 ? 's' : ''}
          </div>
          <table>
            <thead>
              <tr>
                ${keys.map(key => `<th>${escapeHtml(key)}</th>`).join('')}
              </tr>
            </thead>
            <tbody>
      `;
      
      results.forEach(item => {
        html += '<tr>';
        keys.forEach(key => {
          const value = item[key];
          if (key === '@id') {
            html += `<td class="table-id" title="${escapeHtml(value || '')}">${escapeHtml(value || '-')}</td>`;
          } else {
            html += `<td>${escapeHtml(value !== undefined ? String(value) : '-')}</td>`;
          }
        });
        html += '</tr>';
      });
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      output.innerHTML = html;
    }

    function displayNetwork(results, output) {
      output.innerHTML = `
        <div id="networkGraph">
          <div class="graph-controls">
            <button onclick="resetZoom()">Reset Zoom</button>
          </div>
          <div class="tooltip" id="tooltip"></div>
        </div>
      `;

      const width = output.offsetWidth;
      const height = 600;

      // Create nodes and links
      const nodes = results.map((item, i) => ({
        id: item['@id'] || i,
        name: item.name || 'Unnamed',
        type: item['@type'] || 'Unknown',
        category: item.category || '',
        data: item
      }));

      // Create links based on categories (grouping)
      const categoryMap = {};
      nodes.forEach(node => {
        if (!categoryMap[node.category]) {
          categoryMap[node.category] = [];
        }
        categoryMap[node.category].push(node);
      });

      const links = [];
      Object.values(categoryMap).forEach(categoryNodes => {
        for (let i = 0; i < categoryNodes.length - 1; i++) {
          links.push({
            source: categoryNodes[i].id,
            target: categoryNodes[i + 1].id
          });
        }
      });

      // Create SVG
      const svg = d3.select('#networkGraph')
        .append('svg')
        .attr('width', width)
        .attr('height', height);

      const g = svg.append('g');

      // Add zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });

      svg.call(zoom);
      window.resetZoom = () => {
        svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
      };

      // Color scale
      const color = d3.scaleOrdinal(d3.schemeCategory10);

      // Create force simulation
      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-300))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));

      // Create links
      const link = g.append('g')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('class', 'link');

      // Create nodes
      const node = g.append('g')
        .selectAll('g')
        .data(nodes)
        .join('g')
        .attr('class', 'node')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      node.append('circle')
        .attr('r', 8)
        .attr('fill', d => color(d.type));

      node.append('text')
        .attr('dy', 20)
        .text(d => d.name.length > 15 ? d.name.substring(0, 15) + '...' : d.name);

      // Tooltip
      const tooltip = d3.select('#tooltip');
      
      node.on('mouseover', (event, d) => {
        tooltip.style('opacity', 1)
          .html(`
            <strong>${escapeHtml(d.name)}</strong><br>
            Type: ${escapeHtml(d.type)}<br>
            ${d.category ? `Category: ${escapeHtml(d.category)}<br>` : ''}
          `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px');
      })
      .on('mouseout', () => {
        tooltip.style('opacity', 0);
      });

      // Update positions
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });

      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Preload and cache processes in the background with 24h TTL
    async function preloadProcesses() {
      const info = document.getElementById('mapperInfo');
      try {
        const cacheKey = 'openlca.processDescriptors.v1';
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
          const parsed = JSON.parse(cached);
          if (parsed && Array.isArray(parsed.items) && Date.now() - parsed.savedAt < 24 * 60 * 60 * 1000) {
            cachedProcesses = parsed.items;
            info.textContent = `Loaded ${cachedProcesses.length} processes from cache.`;
            return;
          }
        }

        const res = await fetch(serverUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: requestId++,
            method: 'data/get/descriptors',
            params: { '@type': 'Process' }
          })
        });
        const data = await res.json();
        if (!data || !data.result || !Array.isArray(data.result)) {
          throw new Error('Unexpected response while preloading processes');
        }
        cachedProcesses = data.result;
        localStorage.setItem('openlca.processDescriptors.v1', JSON.stringify({ items: cachedProcesses, savedAt: Date.now() }));
        info.textContent = `Loaded ${cachedProcesses.length} processes from server.`;
      } catch (e) {
        info.textContent = `Background load failed: ${e.message}`;
      }
    }

    function setupMapper() {
      const input = document.getElementById('productInput');
      const suggestions = document.getElementById('suggestions');
      const meta = document.getElementById('matchMeta');
      const viewBtn = document.getElementById('viewMatchBtn');

      let lastQuery = '';
      let debounceTimer;

      input.addEventListener('input', () => {
        const q = input.value.trim();
        lastQuery = q;
        clearTimeout(debounceTimer);
        if (!q) {
          suggestions.style.display = 'none';
          suggestions.innerHTML = '';
          meta.textContent = '';
          bestMatch = null;
          viewBtn.disabled = true;
          return;
        }
        debounceTimer = setTimeout(() => doSearch(q, suggestions, meta, viewBtn), 150);
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (bestMatch) {
            showBestMatch();
          }
        }
      });

      viewBtn.addEventListener('click', showBestMatch);

      function showBestMatch() {
        if (!bestMatch) return;
        // Reuse existing renderer to show details card for the matched process
        displayResponse({ result: [bestMatch.item] });
        switchView('cards');
        document.getElementById('output').scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function doSearch(query, suggestionsEl, metaEl, viewBtn) {
      if (!cachedProcesses || cachedProcesses.length === 0) {
        metaEl.textContent = 'Process data not loaded yet.';
        suggestionsEl.style.display = 'none';
        suggestionsEl.innerHTML = '';
        viewBtn.disabled = true;
        return;
      }

      const ranked = rankMatches(query, cachedProcesses).slice(0, 20);
      suggestionsEl.innerHTML = ranked.map(r => `
        <div class="suggestion-item" data-id="${escapeHtml(r.item['@id'] || '')}">
          <div>
            <div style="font-weight:600;color:#1e293b;">${escapeHtml(r.item.name || 'Unnamed')}</div>
            <div style="font-size:12px;color:#64748b;">
              ${(r.item.category ? escapeHtml(r.item.category) + ' · ' : '') + (r.item.processType ? escapeHtml(r.item.processType) : '')}
            </div>
          </div>
          <span class="match-badge">${Math.round(r.score * 100)}%</span>
        </div>
      `).join('');

      suggestionsEl.style.display = ranked.length ? 'block' : 'none';
      metaEl.textContent = ranked.length ? `Top ${ranked.length} results shown` : 'No matches';

      // Keep best match reference
      bestMatch = ranked[0] || null;
      viewBtn.disabled = !bestMatch;

      // Click handling
      Array.from(suggestionsEl.children).forEach((child, idx) => {
        child.addEventListener('click', () => {
          bestMatch = ranked[idx];
          viewBtn.disabled = false;
          // Show immediately on click
          displayResponse({ result: [bestMatch.item] });
          switchView('cards');
          document.getElementById('output').scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
      });
    }

    // Lightweight fuzzy ranking: combines normalized Levenshtein, prefix bonus, token overlap
    function rankMatches(query, items) {
      const q = query.toLowerCase();
      const qTokens = q.split(/[^a-z0-9]+/).filter(Boolean);

      const scored = items.map(item => {
        const name = (item.name || '').toLowerCase();
        if (!name) return { item, score: 0 };
        const nameTokens = name.split(/[^a-z0-9]+/).filter(Boolean);

        const lev = 1 - (levenshtein(q, name) / Math.max(q.length, name.length));
        const prefix = name.startsWith(q) ? 0.2 : 0;
        const tokenOverlap = jaccard(qTokens, nameTokens) * 0.6;
        const score = Math.max(0, Math.min(1, lev * 0.5 + tokenOverlap + prefix));
        return { item, score };
      });

      return scored
        .filter(s => s.score > 0)
        .sort((a, b) => b.score - a.score);
    }

    function jaccard(aTokens, bTokens) {
      if (aTokens.length === 0 || bTokens.length === 0) return 0;
      const aSet = new Set(aTokens);
      const bSet = new Set(bTokens);
      let inter = 0;
      aSet.forEach(t => { if (bSet.has(t)) inter++; });
      const union = aSet.size + bSet.size - inter;
      return union === 0 ? 0 : inter / union;
    }

    function levenshtein(a, b) {
      const m = a.length, n = b.length;
      if (m === 0) return n;
      if (n === 0) return m;
      const dp = new Array(n + 1);
      for (let j = 0; j <= n; j++) dp[j] = j;
      for (let i = 1; i <= m; i++) {
        let prev = dp[0];
        dp[0] = i;
        for (let j = 1; j <= n; j++) {
          const temp = dp[j];
          dp[j] = Math.min(
            dp[j] + 1,
            dp[j - 1] + 1,
            prev + (a[i - 1] === b[j - 1] ? 0 : 1)
          );
          prev = temp;
        }
      }
      return dp[n];
    }

    async function getDescriptors(type) {
      const output = document.getElementById('output');
      output.innerHTML = `
        <div class="empty-state">
          <div class="loading"></div>
          <p style="margin-top: 20px;">Loading...</p>
        </div>
      `;

      try {
        const response = await fetch(serverUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: requestId++,
            method: "data/get/descriptors",
            params: {
              "@type": type
            }
          })
        });

        const data = await response.json();
        displayResponse(data);
        
        document.getElementById('status').textContent = 'Connected';
        document.getElementById('status').className = 'status connected';
      } catch (error) {
        output.innerHTML = `
          <div class="empty-state" style="color: #ef4444;">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p style="font-weight: 600;">Connection Error</p>
            <p style="font-size: 14px; margin-top: 8px;">${error.message}</p>
          </div>
        `;
        
        document.getElementById('status').textContent = 'Disconnected';
        document.getElementById('status').className = 'status disconnected';
      }
    }

    async function sendCustomRequest() {
      const output = document.getElementById('output');
      const customPayload = document.getElementById('customPayload').value;

      output.innerHTML = `
        <div class="empty-state">
          <div class="loading"></div>
          <p style="margin-top: 20px;">Loading...</p>
        </div>
      `;

      try {
        const payload = JSON.parse(customPayload);
        
        const response = await fetch(serverUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        const data = await response.json();
        displayResponse(data);
        
        document.getElementById('status').textContent = 'Connected';
        document.getElementById('status').className = 'status connected';
      } catch (error) {
        output.innerHTML = `
          <div class="empty-state" style="color: #ef4444;">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p style="font-weight: 600;">Error</p>
            <p style="font-size: 14px; margin-top: 8px;">${error.message}</p>
          </div>
        `;
        
        document.getElementById('status').textContent = 'Disconnected';
        document.getElementById('status').className = 'status disconnected';
      }
    }
  </script>
</body>
</html>